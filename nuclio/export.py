# Copyright 2018 Iguazio
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import re
from datetime import datetime
from io import StringIO
from os.path import abspath, dirname, join
from subprocess import check_output
from textwrap import indent
from urllib.parse import urlencode, urljoin
from urllib.request import urlopen

import ipykernel
from nbconvert.exporters import Exporter
from nbconvert.filters import ipython2python
from notebook.notebookapp import list_running_servers

here = dirname(abspath(__file__))

#  '# nuclio: ignore'
is_ignore = re.compile(r'%nuclio:\s+ignore').search
#  '%nuclio handler'
is_handler = re.compile(r'%nuclio\s+handler').search
#  '%nuclio return'
is_return = re.compile(r'%nuclio\s+return').search
handler_decl = 'def handler(context, event):'
indent_prefix = '    '


class NuclioExporter(Exporter):
    """Export to nuclio handler"""

    # Add "File -> Download as" menu in the notebook
    export_from_notebook = 'Nuclio'

    output_mimetype = 'application/zip'

    def _file_extension_default(self):
        """Return default file extension"""
        return '.zip'

    def convert(self, code):
        code = ipython2python(code)

        if is_ignore(code):
            return ''

        if not is_handler(code):
            return code

        lines = [handler_decl]
        code = indent(code, indent_prefix)
        for line in code.splitlines():
            if is_return(line):
                line = self.add_return(line)
            lines.append(line)

        # Add return to last code line (if not there)
        last_idx = len(lines) - 1
        for i, line in enumerate(reversed(lines[1:])):
            if not self.is_code_line(line):
                continue

            if 'return' not in line:
                lines[last_idx-i] = self.add_return(line)
            break

        return '\n'.join(lines)

    def from_notebook_node(self, nb, resources=None, **kw):
        io = StringIO()
        print(self.header(), file=io)

        for cell in filter(self.is_code_cell, nb['cells']):
            code = cell['source']
            print(code, file=io)
        return io.getvalue(), resources

    def header(self):
        cls = self.__class__
        name = '{}.{}'.format(cls.__module__, cls.__name__),
        return '# Generated by {} on {}\n'.format(name, datetime.now())

    def is_code_cell(self, cell):
        return cell['cell_type'] == 'code'

    def is_code_line(self, line):
        """A code line is a non empty line that don't start with #"""
        line = line.strip()
        return line and line[0] != '#'

    def add_return(self, line, prefix=indent_prefix):
        """Add return to a line"""
        return line.replace(prefix, prefix + 'return ', 1)


# Based on
# https://github.com/jupyter/notebook/issues/1000#issuecomment-359875246
def notebook_file_name():
    """Return the full path of the jupyter notebook."""
    kernel_id = re.search('kernel-(.*).json',
                          ipykernel.connect.get_connection_file()).group(1)
    servers = list_running_servers()
    for srv in servers:
        query = {'token': srv.get('token', '')}
        url = urljoin(srv['url'], 'api/sessions') + '?' + urlencode(query)
        for session in json.load(urlopen(url)):
            if session['kernel']['id'] == kernel_id:
                relative_path = session['notebook']['path']
                return join(srv['notebook_dir'], relative_path)


def get_handler_code():
    cmd = [
        'jupyter', 'nbconvert',
        '--to', 'nuclio.export.NuclioExporter',
        '--stdout',
        notebook_file_name(),
    ]

    return check_output(cmd).decode('utf-8')


def print_handler_code():
    """Prints handler code (as it was exported).

   You should save the notebook before calling this function.
    """
    code = get_handler_code()
    print(code)


def save_handler_code(path):
    """Saves handler code to path.

   You should save the notebook before calling this function.
    """
    code = get_handler_code()
    with open(path, 'w') as out:
        out.write(code)
