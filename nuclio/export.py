# Copyright 2018 Iguazio
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import re
import shlex
from collections import namedtuple
from datetime import datetime
from io import StringIO
from os import remove
from os.path import abspath, dirname, join, isfile
from subprocess import check_output
from tempfile import gettempdir
from textwrap import indent
from urllib.parse import urlencode, urljoin
from urllib.request import urlopen
from zipfile import ZipFile

import yaml
import ipykernel
from nbconvert.exporters import Exporter
from nbconvert.filters import ipython2python
from notebook.notebookapp import list_running_servers

from .magic import parse_env, iter_env_lines

here = dirname(abspath(__file__))

Magic = namedtuple('Magic', 'name is_cell args lines')
magic_handlers = {}  # name -> function

#  '# nuclio:return'
is_return = re.compile(r'#\s*nuclio:return').search
handler_decl = 'def handler(context, event):'
indent_prefix = '    '

function_config = {
    'apiVersion': 'nuclio.io/v1',
    'kind': 'Function',
    'metadata': {},
    'spec': {
        'runtime': 'python:3.6',
        'handler': 'handler:handler',
        'env': {},
    },
    'build': {
        'commands': {},
    }
}

zip_file_name = '{}/nuclio_handler.zip'.format(gettempdir())


class NuclioExporter(Exporter):
    """Export to nuclio handler"""

    # Add "File -> Download as" menu in the notebook
    export_from_notebook = 'Nuclio'

    output_mimetype = 'application/zip'

    def _file_extension_default(self):
        """Return default file extension"""
        return '.zip'

    def from_notebook_node(self, nb, resources=None, **kw):
        io = StringIO()
        print(self.header(), file=io)

        for cell in filter(is_code_cell, nb['cells']):
            code = cell['source']
            magic = parse_magic(code)
            if magic:
                handler = magic_handlers.get(magic.name)
                if not handler:
                    raise NameError(
                        'unknown nuclio command: {}'.format(magic.name))

                handler(magic)
                # Comment out magic
                if '%%nuclio' in code:
                    code = re.sub('^', '# ', code, flags=re.MULTILINE)
                else:
                    code = code.replace('%nuclio', '# %nuclio')

            print(ipython2python(code), file=io)

        py_code = io.getvalue()
        config = gen_config(function_config)
        zip_data = gen_zip(py_code, config)
        resources['output_extension'] = '.zip'
        return zip_data, resources

    def header(self):
        name = exporter_name()
        return '# Generated by {} on {}\n'.format(name, datetime.now())


def exporter_name():
    return '{}.{}'.format(NuclioExporter.__module__, NuclioExporter.__name__)


def gen_config(config):
    header = '# Generated by {} on {}\n'.format(
        exporter_name(), datetime.now())
    return header + yaml.dump(config, default_flow_style=False)


def convert(code):
    lines = [handler_decl]
    code = indent(code, indent_prefix)
    for line in code.splitlines():
        if is_return(line):
            line = add_return(line)
        lines.append(line)

    # Add return to last code line (if not there)
    last_idx = len(lines) - 1
    for i, line in enumerate(reversed(lines[1:])):
        if not is_code_line(line):
            continue

            if 'return' not in line:
                lines[last_idx-i] = add_return(line)
            break

        return '\n'.join(lines)


def parse_magic(code):
    lines = [line for line in code.splitlines() if line.strip()]
    if not lines:
        return None

    magic_line = lines[0]
    prefix = '%nuclio'
    i = magic_line.find(prefix)
    if i == -1:
        return None
    is_cell = '%%nuclio' in magic_line

    args = shlex.split(magic_line[i+len(prefix):])
    cmd, args = args[0], args[1:]

    return Magic(cmd, is_cell, args, lines[1:])


def magic_handler(fn):
    magic_handlers[fn.__name__] = fn
    return fn


@magic_handler
def env(magic):
    for line in magic.args + magic.lines:
        key, value = parse_env(line)
        if not key:
            raise ValueError(
                'cannot parse environment value from: {}'.format(line))
        function_config['spec']['env'][key] = value


@magic_handler
def env_file(magic):
    for fname in filter(None, map(str.strip, magic.args + magic.lines)):
        with open(fname) as fp:
            for line in iter_env_lines(fp):
                key, value = parse_env(line)
                if not key:
                    raise ValueError(
                        '%s: cannot parse environment: {}'.format(fname, line))
                function_config['spec']['env'][key] = value


def gen_zip(py_code, config):
    if isfile(zip_file_name):
        remove(zip_file_name)

    with ZipFile(zip_file_name, 'w') as zf:
        with zf.open('handler.py', 'w') as out:
            out.write(py_code.encode('utf-8'))
        with zf.open('function.yaml', 'w') as out:
            out.write(config.encode('utf-8'))

    with open(zip_file_name, 'rb') as fp:
        return fp.read()


def is_code_cell(cell):
    return cell['cell_type'] == 'code'


def is_code_line(line):
    """A code line is a non empty line that don't start with #"""
    line = line.strip()
    return line and line[0] not in ('#', '%')


def add_return(line, prefix=indent_prefix):
    """Add return to a line"""
    return line.replace(prefix, prefix + 'return ', 1)


# Based on
# https://github.com/jupyter/notebook/issues/1000#issuecomment-359875246
def notebook_file_name():
    """Return the full path of the jupyter notebook."""
    kernel_id = re.search('kernel-(.*).json',
                          ipykernel.connect.get_connection_file()).group(1)
    servers = list_running_servers()
    for srv in servers:
        query = {'token': srv.get('token', '')}
        url = urljoin(srv['url'], 'api/sessions') + '?' + urlencode(query)
        for session in json.load(urlopen(url)):
            if session['kernel']['id'] == kernel_id:
                relative_path = session['notebook']['path']
                return join(srv['notebook_dir'], relative_path)


def get_handler_code():
    cmd = [
        'jupyter', 'nbconvert',
        '--to', 'nuclio.export.NuclioExporter',
        '--stdout',
        notebook_file_name(),
    ]

    return check_output(cmd).decode('utf-8')


def print_handler_code():
    """Prints handler code (as it was exported).

   You should save the notebook before calling this function.
    """
    code = get_handler_code()
    print(code)


def save_handler_code(path):
    """Saves handler code to path.

   You should save the notebook before calling this function.
    """
    code = get_handler_code()
    with open(path, 'w') as out:
        out.write(code)
